# 시크릿 인증 관리 (Secret Credential Management)

## 정의

데이터베이스 비밀번호, API 토큰 같은 시크릿을 애플리케이션 코드나 컨테이너 이미지에 직접 포함하지 않고, 실행 환경에서 안전하게 주입하고 통제하는 방법.

## 왜 중요한가?

- 시크릿이 코드 저장소에 들어가면 저장소 접근 권한자에게 과도한 접근이 열린다.
- 시크릿이 이미지에 포함되면 이미지 접근 권한자에게 운영 자격증명이 노출될 수 있다.
- 시크릿이 코드/이미지에 고정되면 환경(개발, 카나리, 운영)마다 별도 이미지가 필요해져 운영 복잡도가 급증한다.

## 책 내용 핵심 정리

- 레디스처럼 단순 비밀번호 인증을 쓰는 경우라도, 비밀번호를 소스 코드나 이미지 내부 파일에 저장하면 위험하다.
- 실제 서비스 접근이 필요한 사용자보다 소스 코드/이미지 접근자가 더 넓은 경우가 많아 노출 범위가 커진다.
- 시크릿은 소스와 이미지를 분리한 상태로 관리하고, 동일한 코드/이미지를 환경별 파라미터로 재사용해야 한다.

## 실무 포인트

### 1. 코드/이미지와 시크릿 분리
- 애플리케이션 저장소, Dockerfile, 이미지 레이어에 시크릿을 남기지 않는다.
- `.env` 파일 커밋 금지 규칙과 사전 스캔(Secret Scan)을 기본으로 둔다.

### 2. 환경별 파라미터화
- 동일한 이미지 하나를 개발/스테이징/운영에 공통 사용한다.
- 환경 차이는 시크릿 값 주입으로만 분리한다.

### 3. 쿠버네티스 주입 경로 표준화
- Kubernetes Secret 또는 외부 시크릿 매니저(Vault, AWS Secrets Manager 등) 연동을 표준으로 둔다.
- 주입 방식은 환경 변수 또는 파일 마운트 중 하나로 팀 표준을 정하고 일관되게 적용한다.

### 4. 최소 권한과 접근 제어
- 서비스 계정 단위로 필요한 시크릿만 읽게 제한한다.
- 개발자, CI, 런타임 워크로드의 권한 경계를 분리한다.

### 5. 로테이션과 감사 추적
- 시크릿 만료/교체 주기를 운영 정책으로 명시한다.
- 누가 언제 어떤 시크릿을 읽고 갱신했는지 로그를 남긴다.

## 바로 적용 가능한 체크리스트

- [ ] 시크릿 하드코딩(코드, Dockerfile, 이미지 레이어) 금지
- [ ] 시크릿 스캔을 PR/CI 단계에서 자동 실행
- [ ] 단일 이미지 + 환경별 시크릿 주입 방식으로 배포
- [ ] 서비스 계정별 시크릿 접근 권한 최소화
- [ ] 시크릿 로테이션 주기와 사고 대응 절차 문서화

## 실무 한 줄

시크릿 관리는 "어디에 저장할까"가 아니라, **누가 어떤 경로로 언제 접근하는지 끝까지 통제하는 운영 설계**다.

## 관련 개념

- 환경 변수 관리
- GitOps와 시크릿 분리
- External Secrets Operator
- KMS / Vault

## 출처

- 쿠버네티스 창시자에게 배우는 모범 사례 2판
